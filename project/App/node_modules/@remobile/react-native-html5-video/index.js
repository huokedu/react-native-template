'use strict';

var React = require('react');
var {
    View,
} = require('react-native');

var WebViewBridge = require('react-native-webview-bridge');

module.exports =  React.createClass({
    seek(time) {
        this.command('seek', time);
    },
    command(type, data) {
        this.webViewBridge.sendToBridge(JSON.stringify({type:type, data:data}));
    },
    createHtmlPlayer(props) {
        const {source, seek, repeat, volume, rate, paused, muted} = props;
        this.loaded = false;
        this.startPlayTime = seek;
        this.autoplay = !paused;

        this.html =  `
        <body style="margin:0px;padding:0px;">
            <video id=video
                style="width:100%;height:100%;background-color:black;object-fit:fill;"
                src="${source.uri}"
                ontimeupdate="_ontimeupdate(event)"
                onseeked="_onseeked(event)"
                onloadstart="_onloadstart(event)"
                oncanplaythrough="_oncanplaythrough(event)"
                onerror="_onerror(event)"
                onpause="_onpause(event)"
                onplay="_onplay(event)"
                />
            <script>
                var _init = false;
                var el = document.getElementById('video');
                function emit(type, data) {
                    WebViewBridge.send(JSON.stringify({type:type, data:data}));
                }
                WebViewBridge.onMessage = function (message) {
                    var obj = JSON.parse(message);
                    switch (obj.type) {
                        case 'play':
                            el.play();
                        break;
                            case 'pause':
                            el.pause();
                        break;
                        case 'seek':
                            el.currentTime = obj.data;
                        break;
                    }
                };
                function _ontimeupdate(e){
                    emit('ontimeupdate', {currentTime:el.currentTime, duration:el.duration});
                }
                function _onseeked(e){
                    emit('onseeked');
                }
                function _onloadstart(e){
                    emit('onloadstart');
                }
                function _oncanplaythrough(e){
                    emit('oncanplaythrough');
                }
                function _onerror(e){
                    emit('onerror');
                }
                function _onpause(e){
                    emit('onpause', {currentTime:el.currentTime, duration:el.duration});
                }
                function _onplay(e){
                    if (!_init) {
                        _init = true;
                        if (${muted}) {
                            el.muted = ${muted};
                        } else {
                            el.volume = ${volume};
                        }
                        el.loop = ${repeat};
                        el.playbackRate = ${rate};
                    }
                    emit('onplay');
                }
            </script>
        </body>
        `;
    },
    getInitialState() {
        this.createHtmlPlayer(this.props);
        return {
            changeUrl: false,
        };
    },
    componentWillReceiveProps(nextProps) {
        const o = this.props, command = this.command;
        const {source, paused} = nextProps;
        if (paused !== o.paused) {
            paused ? command('pause') : command('play');
        }
        if (source.uri != o.source.uri) {
            this.createHtmlPlayer(nextProps);
            this.setState({changeUrl: true}, ()=>{
                this.setState({changeUrl: false});
            });
        }
    },
    onBridgeMessage(message) {
        const {
            onLoadStart,
            onLoad,
            onProgress,
            onSeek,
            onEnd,
            onError,
            onPause,
            onResume,
            paused,
        } = this.props;
        var obj = JSON.parse(message);
        switch (obj.type) {
            case 'ontimeupdate':
            {
                let {currentTime, duration} = obj.data;
                if (duration > 1) {
                    onProgress && onProgress({currentTime});
                    if (!this.loaded) {
                        this.loaded = true;
                        onLoad && onLoad({duration});
                    }
                    if (this.startPlayTime) {
                        this.command('seek', this.startPlayTime);
                        this.startPlayTime = null;
                    }
                }
            }
            break;
            case 'onseeked':
                this.command('play');
                onSeek && onSeek();
            case 'onloadstart':
                onLoadStart && onLoadStart();
            break;
            case 'oncanplaythrough':
                if (this.autoplay) {
                    this.command('play');
                }
            break;
            case 'onerror':
                onError && onError();
            break;
            case 'onpause':
            {
                let {currentTime, duration} = obj.data;
                if (currentTime == duration) {
                    onEnd && onEnd();
                } else {
                    onPause && onPause();
                }
            }
            break;
            case 'onplay':
                onResume && onResume();
            break;
            default: ;
        }
    },
    componentWillUnmount() {
        this.command('pause');
    },
    render() {
        const style = {position:'absolute', left:0, top:0, bottom:0, right: 0, backgroundColor:'black'};
        return (
            <View style={this.props.style}>
                {
                    this.state.changeUrl ?
                    <View style={style} />
                    :
                    <WebViewBridge
                        ref={(ref)=>this.webViewBridge=ref}
                        onBridgeMessage={this.onBridgeMessage}
                        style={style}
                        source={{html: this.html}}
                        />
                }
            </View>
        );
    }
});
